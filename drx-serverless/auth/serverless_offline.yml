service: '${self:custom.project}-${self:custom.function}-lambda'

custom:
  # project specific variables
  vars: ${file(./variables.json)}
  infoVars: ${file(./aws_infra_parameters.json)}
  resourceVars: ${file(./aws_resource_parameters.json)}
  commonVars: ${file(./lambda_common_env_parameters.json)}
  region: ${env:AWS_REGION}
  environment: ${env:ENVIRONMENT}
  stage: ${env:ENVIRONMENT}
  buildNumber: ${env:CI_PIPELINE_IID}
  project: ${env:PROJECT_CODE}
  APIGWAFV2: ${self:custom.resourceVars.apiWafv2}
  function: auth
  kmsArn: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-kms-arn
  customDomainName: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-api-custom-domain
  customDomainPath: !Sub ${env:PROVIDER}-${self:custom.vars.releaseVersion}
  apiauthorizerArn: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-apiauthorizer
  deploy_bucket: ${env:DEPLOY_S3_BUCKET}
  cloudWatchRole: !Sub 'arn:aws:iam::${AWS::AccountId}:role/cochlear-general-apigateway-log-role'
  secretName: ${env:PROJECT_CODE}/${env:ENVIRONMENT}/serverless/secrets
  redisHostname: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-url
  redisPort: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-port
  redisSG: ${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-security-group

  # serverless plugins specific variables
  serverless-offline:
    httpPort: 3003
    lambdaPort: 3004
    prefix: ${env:PROJECT_CODE}/v1/auth
    noPrependStageInUrl: true

  logRetentionInDays: 30
  apiStageTags:
    Owner: ${self:custom.vars.Owner}
    Description: ${self:custom.vars.Description}
    Name: ${self:custom.project}-${self:custom.function}-lambda
    Function: Serverless
    Environment: ${self:custom.environment}
    Product: ${self:custom.vars.Product}
    Resource: DRX
  apigwBinary:
    types: #list of mime-types
      - '*/*'
  prune:
    automatic: true
    number: 3
  associateWaf:
    name: ${self:custom.APIGWAFV2}
    version: V2
  # warmup:
  #   memorySize: 512
  #   role: warmupRole
  #   events:
  #     - schedule: 'cron(0/15 8-17 ? * MON-FRI *)' # Run WarmUp every 5 minutes Mon-Fri between 8:00am and 5:55pm (UTC)
  #   timeout: 20
  #   prewarm: true # Run WarmUp immediately after a deployment

provider:
  name: aws
  runtime: nodejs20.x
  region: ${self:custom.region}
  vpc:
    securityGroupIds:
      - ${self:custom.redisSG}
    subnetIds: ${self:custom.infoVars.subnets}
  # versionFunctions: false
  endpointType: regional
  stage: ${self:custom.stage}
  deploymentBucket:
    name: ${self:custom.deploy_bucket} # Deployment bucket name. Default is generated by the framework
    serverSideEncryption: AES256 # when using server-side encryption
  memorySize: 512
  timeout: 29
  logs:
    restApi:
      roleManagedExternally: true
      role: ${self:custom.cloudWatchRole}
  stackTags:
    Owner: ${self:custom.vars.Owner}
    project: ${self:custom.project}
    Resource: DRX
  tags:
    Description: ${self:custom.vars.Description}
    Name: '${self:custom.project}-${self:custom.function}'
    Function: 'Serverless'
    Environment: ${self:custom.environment}
    Product: ${self:custom.vars.Product}
    buildNumber: ${self:custom.buildNumber}
  apiGateway:
    disableDefaultEndpoint: true
  environment:
    IS_LOCAL: true

plugins:
  # - serverless-plugin-bind-deployment-id
  - serverless-plugin-optimize
  # - serverless-plugin-warmup
  - api-gateway-stage-tag-plugin
  - serverless-plugin-log-retention
  - serverless-prune-plugin
  - ./serverless-plugin/metric
  - serverless-associate-waf
  - serverless-offline

package: # Optional deployment packaging configuration
  individually: true
  include: # Specify the directories and files which should be included in the deployment package
    - src/**

functions:
  CorsLoginFunction:
    handler: src/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /authorize
          method: OPTIONS
  CorsTokenRevokeFunction:
    handler: src/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsPOSTAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /token
          method: OPTIONS
      - http:
          path: /revoke
          method: OPTIONS
  login:
    handler: src/handler.login
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      auth0CustomDomain: ${self:custom.vars.auth0CustomDomain}
      auth0Host: ${self:custom.vars.auth0Host}
      auth0AuthorizePath: ${self:custom.vars.auth0AuthorizePath}
      auth0ClientId: ${self:custom.vars.auth0ClientId}
      auth0Audience: ${self:custom.vars.auth0Audience}
      auth0ProfessionalApps: ${self:custom.vars.auth0ProfessionalApps}
      auth0RecipientConnectionName: ${self:custom.vars.auth0RecipientConnectionName}
      auth0ProfessionalConnectionName: ${self:custom.vars.auth0ProfessionalConnectionName}
      callback_url: ${self:custom.vars.callback_url}
      secretName: ${self:custom.secretName}
      logLevel: ${self:custom.vars.logLevel}
      DRXBaseUrl: ${self:custom.vars.DRXBaseUrl}
      DRXGetAccountPath: ${self:custom.vars.DRXGetAccountPath}
    role: lambdaRole
    events:
      - http:
          path: /authorize
          method: get
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
              - Location
              - Access-Control-Allow-Origin
    # warmup:
    #   prewarm: true
    #   enabled:
    #     - uat
    #     - prd
    #     - dev
  token:
    handler: src/handler.getToken
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      auth0CustomDomain: ${self:custom.vars.auth0CustomDomain}
      auth0Host: ${self:custom.vars.auth0Host}
      auth0TokenPath: ${self:custom.vars.auth0TokenPath}
      auth0ClientId: ${self:custom.vars.auth0ClientId}
      auth0Audience: ${self:custom.vars.auth0Audience}
      callback_url: ${self:custom.vars.callback_url}
      RedisPort: ${self:custom.redisPort}
      RedisHostname: ${self:custom.redisHostname}
      publicKey: ${self:custom.vars.publicKey}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      userSessionPrefix: ${self:custom.commonVars.userSessionPrefix}
      logLevel: ${self:custom.vars.logLevel}
      DRXBaseUrl: ${self:custom.vars.DRXBaseUrl}
      DRXGetAccountPath: ${self:custom.vars.DRXGetAccountPath}
    role: lambdaRole
    events:
      - http:
          path: /token
          method: post
          # RequestValidatorId: !Ref RequestValidator
          request:
            schemas:
              application/json: ${file(token-post.yml)}
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
    # warmup:
    #   prewarm: true
    #   enabled:
    #     - uat
    #     - prd
    #     - dev
  revoke:
    handler: src/handler.revokeToken
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      auth0CustomDomain: ${self:custom.vars.auth0CustomDomain}
      auth0Host: ${self:custom.vars.auth0Host}
      auth0ClientId: ${self:custom.vars.auth0ClientId}
      auth0RevokePath: ${self:custom.vars.auth0RevokePath}
      blacklistSeconds: ${self:custom.vars.blacklistSeconds}
      RedisPort: ${self:custom.redisPort}
      RedisHostname: ${self:custom.redisHostname}
      publicKey: ${self:custom.vars.publicKey}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      logLevel: ${self:custom.vars.logLevel}
    role: lambdaRole
    events:
      - http:
          path: /revoke
          method: post
          # RequestValidatorId: !Ref RequestValidator
          request:
            schemas:
              application/json: ${file(revoke-post.yml)}
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
    # warmup:
    #   prewarm: true
    #   enabled:
    #     - uat
    #     - prd
    #     - dev
## Resources ##
resources:
  Resources:
    CustomDomainMapping:
      Type: AWS::ApiGateway::BasePathMapping
      DependsOn:
        - 'ApiGatewayDeployment${sls:instanceId}'
      Properties:
        RestApiId: !Ref ApiGatewayRestApi
        BasePath: ${self:custom.customDomainPath}
        DomainName:
          ${self:custom.customDomainName}
          # 'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-api-custom-domain'
        Stage: ${self:custom.stage}
    # RequestValidator:
    #   Type: AWS::ApiGateway::RequestValidator
    #   Properties:
    #     RestApiId: !Ref ApiGatewayRestApi
    #     ValidateRequestBody: true
    #     ValidateRequestParameters: false
    # DRXLambdaSecurityGroup:
    #   Type: AWS::EC2::SecurityGroup
    #   Properties:
    #     GroupDescription: DRX Lambda auth security group
    #     GroupName: cochlear-drx-auth-${self:custom.vars.stage}-lambda-${opt:versionNumber,"0"}
    #     VpcId: ${self:custom.vars.vpc}
    #     SecurityGroupIngress:
    #       - IpProtocol: tcp
    #         FromPort: 6379
    #         ToPort: 6379
    #         CidrIp: ${self:custom.vars.vpcCidr}
    #     SecurityGroupEgress:
    #       - IpProtocol: -1
    #         FromPort: -1
    #         ToPort: -1
    #         CidrIp: 0.0.0.0/0
    #     Tags:
    #       - Key: 'Name'
    #         Value: cochlear-drx-auth-${self:custom.vars.stage}-lambda-${opt:versionNumber,"0"}
    #       - Key: 'Environment'
    #         Value: ${self:custom.vars.stage}
    #       - Key: 'Resource'
    #         Value: 'cochlear-drx'
    #       - Key: 'Version'
    #         Value: ${opt:versionNumber,"0"}
    lambdaRole:
      Type: AWS::IAM::Role
      Properties:
        Path: /drx/all/
        PermissionsBoundary: !Sub 'arn:aws:iam::${AWS::AccountId}:policy/core/PermissionsBoundary'
        ManagedPolicyArns: [
            'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole',
            'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
          ] ## Allows VPC Execution rights for Lambda
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: LambdaDRX
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow # Default Lambda Permissions for Cloudwatch Log Access
                  Resource: arn:aws:logs:${self:custom.region}:*:log-group:/aws/lambda/*:*:*
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                - Effect: Allow
                  Resource:
                    - arn:aws:ssm:${self:custom.region}:*:parameter/*
                  Action:
                    - ssm:GetParameter
                - Effect: Allow
                  Resource:
                    - arn:aws:secretsmanager:${self:custom.region}:*:*
                  Action:
                    - secretsmanager:GetSecretValue
    # warmupRole:
    #   Type: AWS::IAM::Role
    #   Properties:
    #     Path: /drx/all/
    #     ManagedPolicyArns: [
    #         'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole',
    #       ] ## Allows VPC Execution rights for Lambda
    #     AssumeRolePolicyDocument:
    #       Version: '2012-10-17'
    #       Statement:
    #         - Effect: Allow
    #           Principal:
    #             Service:
    #               - lambda.amazonaws.com
    #           Action: sts:AssumeRole
    #     Policies:
    #       - PolicyName: LambdaWarmupDRX
    #         PolicyDocument:
    #           Version: '2012-10-17'
    #           Statement:
    #             - Effect: Allow # WarmUp lambda to send logs to CloudWatch
    #               Action:
    #                 - logs:CreateLogGroup
    #                 - logs:CreateLogStream
    #                 - logs:PutLogEvents
    #               Resource:
    #                 - 'Fn::Join':
    #                     - ':'
    #                     - - 'arn:aws:logs'
    #                       - Ref: 'AWS::Region'
    #                       - Ref: 'AWS::AccountId'
    #                       - 'log-group:/aws/lambda/*:*:*'
    #             - Effect: Allow # WarmUp lambda to manage ENIS (only needed if deploying to VPC, https://docs.aws.amazon.com/lambda/latest/dg/vpc.html)
    #               Action:
    #                 - ec2:CreateNetworkInterface
    #                 - ec2:DescribeNetworkInterfaces
    #                 - ec2:DetachNetworkInterface
    #                 - ec2:DeleteNetworkInterface
    #               Resource: '*'
    #             - Effect: 'Allow' # WarmUp lambda to invoke the functions to be warmed
    #               Action:
    #                 - 'lambda:InvokeFunction'
    #               Resource:
    #                 - Fn::Join:
    #                     - ':'
    #                     - - arn:aws:lambda
    #                       - Ref: AWS::Region
    #                       - Ref: AWS::AccountId
    #                       - function:${self:service}-${opt:stage, self:provider.stage}-*

  Outputs:
    RestApiId:
      Description: 'rest api id'
      Value:
        Ref: ApiGatewayRestApi
    # DRXLambdaSecurityGroupId:
    #   Description: 'DRXLambdaSecurityGroup id'
    #   Value:
    #     Ref: DRXLambdaSecurityGroup
