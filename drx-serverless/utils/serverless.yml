service: '${self:custom.project}-${self:custom.function}-lambda'

custom:
  # project specific variables
  vars: ${file(./variables.json)}
  infoVars: ${file(./aws_infra_parameters.json)}
  resourceVars: ${file(./aws_resource_parameters.json)}
  commonVars: ${file(./lambda_common_env_parameters.json)}
  region: ${env:AWS_REGION}
  environment: ${env:ENVIRONMENT}
  stage: ${env:ENVIRONMENT}
  buildNumber: ${env:CI_PIPELINE_IID}
  project: ${env:PROJECT_CODE}
  APIGWAFV2: ${self:custom.resourceVars.apiWafv2}
  function: utils
  kmsArn:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-kms-arn'
  customDomainName:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-api-custom-domain'
  customDomainPath: !Sub ${env:PROVIDER}-${self:custom.vars.releaseVersion}
  apiauthorizerArn:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-apiauthorizer'
  deploy_bucket: ${env:DEPLOY_S3_BUCKET}
  cloudWatchRole: !Sub 'arn:aws:iam::${AWS::AccountId}:role/cochlear-general-apigateway-log-role'
  secretName:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-serverless-secret-name'
  redisHostname:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-url'
  redisPort:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-port'
  redisSG:
    'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-redis-security-group'

  # API Gateway caching configuration
  apiGatewayCaching:
    enabled: true
    clusterSize: '0.5'  # Smallest cluster size (most cost-effective)
    ttlInSeconds: 3600  # Default 1 hour TTL
    dataEncrypted: false  # Set to true in production for better security
    perKeyInvalidation:
      requireAuthorization: false
      handleUnauthorizedRequests: Ignore

  # serverless plugins specific variables
  functionEnabled:
    dev: false
    sit: true
    uat: true
    # Important: Cache function must never be enabled in prd
    prd: false
  logRetentionInDays: 30
  apiStageTags:
    Owner: ${self:custom.vars.Owner}
    Description: ${self:custom.vars.Description}
    Name: ${self:custom.project}-${self:custom.function}-lambda
    Function: Serverless
    Environment: ${self:custom.vars.Environment}
    Product: ${self:custom.vars.Product}
    Resource: DRX
  apigwBinary:
    types: # list of mime-types
      - '*/*'
  prune:
    automatic: true
    number: 3
  associateWaf:
    name: ${self:custom.APIGWAFV2}
    version: V2

provider:
  name: aws
  runtime: nodejs20.x
  region: ${self:custom.region}
  vpc:
    securityGroupIds:
      - ${self:custom.redisSG}
    subnetIds: ${self:custom.infoVars.subnets}
  endpointType: regional
  stage: ${self:custom.stage}
  deploymentBucket:
    name: ${self:custom.deploy_bucket} # Deployment bucket name. Default is generated by the framework
    serverSideEncryption: AES256 # when using server-side encryption
  memorySize: 512
  timeout: 30
  logs:
    restApi:
      roleManagedExternally: true
      role: ${self:custom.cloudWatchRole}
  stackTags:
    Owner: ${self:custom.vars.Owner}
    project: ${self:custom.project}
    Resource: DRX
  tags:
    Description: ${self:custom.vars.Description}
    Name: '${self:custom.project}-${self:custom.function}'
    Function: 'Serverless'
    Environment: ${self:custom.vars.Environment}
    Product: ${self:custom.vars.Product}
    buildNumber: ${self:custom.buildNumber}
  tracing:
    apiGateway: true
    lambda: true
  apiGateway:
    disableDefaultEndpoint: true

plugins:
  - serverless-disable-functions
  - serverless-plugin-optimize
  - serverless-api-gateway-caching
  - api-gateway-stage-tag-plugin
  - serverless-plugin-log-retention
  - serverless-prune-plugin
  - ../serverless-plugin/metric
  - serverless-associate-waf

package: # Optional deployment packaging configuration
  individually: true
  include: # Specify the directories and files which should be included in the deployment package
    - src/**

functions:
  CorsGetPhoneFunction:
    handler: src/common/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /convert-phone/{phoneNumber}
          method: OPTIONS

  ConvertPhone:
    handler: src/handler.convertPhone
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
    role: lambdaRole
    events:
      - http:
          path: /convert-phone/{phoneNumber}
          method: GET
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsGetAddressConfigFunction:
    handler: src/common/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /address-config/{country}/{lng}
          method: OPTIONS

  GetAddressConfig:
    handler: src/handler.getAddressConfig
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      environment: ${self:custom.environment}
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      scEndpoint: ${self:custom.commonVars.scEndpoint}
      isScHttpAgent: ${self:custom.vars.isScHttpAgent}
      regionsEndpoint: ${self:custom.vars.regionsEndpoint}
    role: lambdaRole
    events:
      - http:
          path: /address-config/{country}/{lng}
          method: GET
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsGetDictionaryItemsFunction:
    handler: src/common/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /dictionary/{lng}
          method: OPTIONS

  GetDictionaryItems:
    provisionedConcurrency: 2  # Keep 2 warm instances
    memorySize: 1024  # Higher memory for faster cold starts
    handler: src/handler.getDictionaryItems
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      environment: ${self:custom.environment}
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      dictionarySessionSeconds: ${self:custom.vars.dictionarySessionSeconds}
      scAuthorEndpoint: ${self:custom.commonVars.scAuthorEndpoint}
      isScHttpAgent: ${self:custom.vars.isScHttpAgent}
    role: lambdaRole
    events:
      - http:
          path: /dictionary/{lng}
          method: GET
          caching:
            enabled: true
            ttlInSeconds: 3600  # 1 hour cache
            cacheKeyParameters:
              - name: request.path.lng
            perRequestCache: false
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsGetCacheFunction:
    handler: src/common/cors-handler.handleRequest
    enabled: ${self:custom.functionEnabled.${self:custom.stage}}
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /cache/{key}
          method: OPTIONS

  GetCache:
    handler: src/handler.getCache
    enabled: ${self:custom.functionEnabled.${self:custom.stage}}
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      environment: ${self:custom.environment}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      cacheApiKey: ${self:custom.commonVars.cacheApiKey}
    role: lambdaRole
    events:
      - http:
          path: /cache/{key}
          method: GET
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsUpdateCacheFunction:
    handler: src/common/cors-handler.handleRequest
    enabled: ${self:custom.functionEnabled.${self:custom.stage}}
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /cache
          method: OPTIONS

  UpdateCache:
    handler: src/handler.postCache
    enabled: ${self:custom.functionEnabled.${self:custom.stage}}
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      environment: ${self:custom.environment}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      cacheApiKey: ${self:custom.commonVars.cacheApiKey}
    role: lambdaRole
    events:
      - http:
          path: /cache
          method: POST
          request:
            schemas:
              application/json: ${file(updateCache-post.yml)}
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsSendMailFunction:
    handler: src/common/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /send-mail
          method: OPTIONS

  SendMail:
    handler: src/handler.sendMail
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      environment: ${self:custom.environment}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      redisTokenKey: ${self:custom.commonVars.redisTokenKey}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      tokenSessionSeconds: ${self:custom.vars.tokenSessionSeconds}
      sfHostname: ${self:custom.commonVars.sfHostname}
      sfClientId: ${self:custom.commonVars.sfClientID}
      sfUsername: ${self:custom.commonVars.sfUsername}
    role: lambdaRole
    events:
      - http:
          path: /send-mail
          method: POST
          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false

  CorsUpdateLoginFunction:
    handler: src/common/cors-handler.handleRequest
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      corsAllowedHeaders: ${self:custom.commonVars.corsAllowedHeaders}
      corsAllowedMethods: ${self:custom.commonVars.corsGETAllowedMethods}
      corsOrigin: ${self:custom.commonVars.corsOrigin}
      corsMaxAge: ${self:custom.commonVars.corsMaxAge}
    role: lambdaRole
    events:
      - http:
          path: /update-login
          method: OPTIONS

  UpdateLogin:
    handler: src/handler.updateLogin
    kmsKeyArn: ${self:custom.kmsArn}
    environment:
      region: ${self:custom.region}
      secretName: ${self:custom.secretName}
      releaseVersion: ${self:custom.vars.releaseVersion}
      logLevel: ${self:custom.vars.logLevel}
      environment: ${self:custom.environment}
      redisPort: ${self:custom.redisPort}
      redisHostname: ${self:custom.redisHostname}
      redisTokenKey: ${self:custom.commonVars.redisTokenKey}
      userSessionSeconds: ${self:custom.vars.userSessionSeconds}
      tokenSessionSeconds: ${self:custom.vars.tokenSessionSeconds}
      sfHostname: ${self:custom.commonVars.sfHostname}
      sfClientId: ${self:custom.commonVars.sfClientID}
      sfUsername: ${self:custom.commonVars.sfUsername}
    role: lambdaRole
    events:
      - http:
          path: /update-login
          method: POST
          request:
            schemas:
              application/json: ${file(updateLogin-post.yml)}

          cors:
            origins: '*'
            headers:
              - Content-Type
              - x-api-token
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - authorizationtoken
            allowCredentials: false
          authorizer:
            name: authorizer
            arn:
              ${self:custom.apiauthorizerArn}
              # 'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-apiauthorizer'
            type: request
            resultTtlInSeconds: 0
            identitySource: method.request.header.Authorization

resources:
  Conditions:
    CreateAlarm:
      Fn::Equals:
        - ${self:custom.vars.createAlarms}
        - 'true'
  Resources:
    CustomDomainMapping:
      Type: AWS::ApiGateway::BasePathMapping
      DependsOn:
        - 'ApiGatewayDeployment${sls:instanceId}'
      Properties:
        RestApiId: !Ref ApiGatewayRestApi
        BasePath: ${self:custom.customDomainPath}
        DomainName:
          ${self:custom.customDomainName}
          # 'Fn::ImportValue': '${env:PROJECT_CODE}-${env:ENVIRONMENT}-api-custom-domain'
        Stage: ${self:custom.stage}

    ConvertPhoneLambdaFunctionErrorAlarm:
      Type: AWS::CloudWatch::Alarm
      Condition: CreateAlarm
      Properties:
        AlarmActions:
          - ${self:custom.commonVars.alarmSNS}
        AlarmDescription: 'DRX lambda fail'
        AlarmName: !Join
          - '-'
          - - 'DRX-lambda-ConvertPhone-fail'
            - ${self:custom.stage}
            # - ${opt:versionNumber,"0"}
        ComparisonOperator: GreaterThanOrEqualToThreshold
        EvaluationPeriods: '1'
        Namespace: AWS/Lambda
        MetricName: Errors
        Dimensions:
          - Name: FunctionName
            Value: !Ref ConvertPhoneLambdaFunction
        Period: '60'
        Statistic: Sum
        Threshold: '1'
        TreatMissingData: 'notBreaching'
        OKActions:
          - ${self:custom.commonVars.alarmSNS}

    SendMailLambdaFunctionErrorAlarm:
      Type: AWS::CloudWatch::Alarm
      Condition: CreateAlarm
      Properties:
        AlarmActions:
          - ${self:custom.commonVars.alarmSNS}
        AlarmDescription: 'DRX lambda fail'
        AlarmName: !Join
          - '-'
          - - 'DRX-lambda-SendMail-fail'
            - ${self:custom.stage}
            # - ${opt:versionNumber,"0"}
        ComparisonOperator: GreaterThanOrEqualToThreshold
        EvaluationPeriods: '1'
        Namespace: AWS/Lambda
        MetricName: Errors
        Dimensions:
          - Name: FunctionName
            Value: !Ref SendMailLambdaFunction
        Period: '60'
        Statistic: Sum
        Threshold: '1'
        TreatMissingData: 'notBreaching'
        OKActions:
          - ${self:custom.commonVars.alarmSNS}

    GetDictionaryItemsLambdaFunctionErrorAlarm:
      Type: AWS::CloudWatch::Alarm
      Condition: CreateAlarm
      Properties:
        AlarmActions:
          - ${self:custom.commonVars.alarmSNS}
        AlarmDescription: 'DRX lambda fail'
        AlarmName: !Join
          - '-'
          - - 'DRX-lambda-GetDictionaryItems-fail'
            - ${self:custom.stage}
            # - ${opt:versionNumber,"0"}
        ComparisonOperator: GreaterThanOrEqualToThreshold
        EvaluationPeriods: '1'
        Namespace: AWS/Lambda
        MetricName: Errors
        Dimensions:
          - Name: FunctionName
            Value: !Ref GetDictionaryItemsLambdaFunction
        Period: '60'
        Statistic: Sum
        Threshold: '1'
        TreatMissingData: 'notBreaching'
        OKActions:
          - ${self:custom.commonVars.alarmSNS}
          
    # GetCacheLambdaFunctionErrorAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Condition: CreateAlarm
    #   Properties:
    #     AlarmActions:
    #       - ${self:custom.commonVars.alarmSNS}
    #     AlarmDescription: 'DRX lambda fail'
    #     AlarmName: !Join
    #       - '-'
    #       - - 'DRX-lambda-GetCache-fail'
    #         - ${self:custom.stage}
    #         # - ${opt:versionNumber,"0"}
    #     ComparisonOperator: GreaterThanOrEqualToThreshold
    #     EvaluationPeriods: '1'
    #     Namespace: AWS/Lambda
    #     MetricName: Errors
    #     Dimensions:
    #       - Name: FunctionName
    #         Value: !Ref GetCacheLambdaFunction
    #     Period: '60'
    #     Statistic: Sum
    #     Threshold: '1'
    #     TreatMissingData: 'notBreaching'
    #     OKActions:
    #       - ${self:custom.commonVars.alarmSNS}
    # UpdateCacheLambdaFunctionErrorAlarm:
    #   Type: AWS::CloudWatch::Alarm
    #   Condition: CreateAlarm
    #   Properties:
    #     AlarmActions:
    #       - ${self:custom.commonVars.alarmSNS}
    #     AlarmDescription: 'DRX lambda fail'
    #     AlarmName: !Join
    #       - '-'
    #       - - 'DRX-lambda-UpdateCache-fail'
    #         - ${self:custom.stage}
    #         # - ${opt:versionNumber,"0"}
    #     ComparisonOperator: GreaterThanOrEqualToThreshold
    #     EvaluationPeriods: '1'
    #     Namespace: AWS/Lambda
    #     MetricName: Errors
    #     Dimensions:
    #       - Name: FunctionName
    #         Value: !Ref UpdateCacheLambdaFunction
    #     Period: '60'
    #     Statistic: Sum
    #     Threshold: '1'
    #     TreatMissingData: 'notBreaching'
    #     OKActions:
    #       - ${self:custom.commonVars.alarmSNS}
    GatewayResponseDefault4XX:
      Type: 'AWS::ApiGateway::GatewayResponse'
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        ResponseType: DEFAULT_4XX
        RestApiId:
          Ref: 'ApiGatewayRestApi'

    lambdaRole:
      Type: AWS::IAM::Role
      Properties:
        Path: /drx/all/
        PermissionsBoundary: !Sub 'arn:aws:iam::${AWS::AccountId}:policy/core/PermissionsBoundary'
        ManagedPolicyArns:
          [
            'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole',
            'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
          ]
        AssumeRolePolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - lambda.amazonaws.com
              Action: sts:AssumeRole
        Policies:
          - PolicyName: LambdaDRX
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow # Default Lambda permission's for Cloudwatch Log Access
                  Resource: arn:aws:logs:${self:custom.region}:*:log-group:/aws/lambda/*:*:*
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                - Effect: Allow
                  Resource:
                    - arn:aws:ssm:${self:custom.region}:*:parameter/*
                  Action:
                    - ssm:GetParameter
                - Effect: Allow
                  Resource:
                    - arn:aws:secretsmanager:${self:custom.region}:*:*
                  Action:
                    - secretsmanager:GetSecretValue

  Outputs:
    RestApiId:
      Description: 'rest api id'
      Value:
        Ref: ApiGatewayRestApi
